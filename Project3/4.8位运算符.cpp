#include <iostream>

//位运算符作用于int类型的运算对象，并把运算对象看成是二进制位的集合
//位运算符提供检查和设置二进制位的功能


int main()
{
    //移位运算符

    //由于符号位如何处理没有明确的规定，所以最好仅将位运算符用于处理无符号类型

    /*
     * <<和>>两种运算符的内置含义是对其运算对象执行基于二进制位的移动操作
     * 首先令其左侧运算对象的内容按照右侧运算对象的要求移动指定位数
     * 然后将经过移动的（可能还进行了提升）的左侧运算符的拷贝作为运算结果
     */
    unsigned char bits = 0233;//10011011
    bits << 8;//bits提升成int类型，然后向左移动8位
    //00000000 00000000 10011011 00000000
    bits << 31;//向左移动31位，左边超出边界的位丢掉了
    //10000000 00000000 00000000 00000000
    bits >> 3;//向右移动3位，最右边的3位丢弃掉了
    //00000000 00000000 00000000 00010011

    //位求反运算符
    unsigned char bits2 = 0227;
    ~bits2;
    //00000000 00000000 00000000 10010111
    //transformed into
    //11111111 11111111 11111111 01101000

    //位与、位或、位异或运算符

    unsigned char bits3 = 0145; //01100101
    unsigned char bits4 = 0257; //10101111
    bits3 & bits4;   //00100101
    bits3 | bits4;  //11101111
    bits ^ bits4;     //11001010
    //对于位与运算符（&），如果两个运算对象的对应位置都是1则运算结果中该位为1，否则为0；
    //对于位或运算符（|），如果两个运算对象的对应位置至少有一个为1则运算结果中该位为1，否则为0；
    //对于位异或运算符（^），如果两个运算对象的对应位置有且只有一个为1则运算结果该位为1，否则为0；

    //例子 班里30个学生，进行测验，结果只有通过和不通过，每个二进制位数代表某个学生在测验中是否通过
    unsigned long quiz = 0;
    //现在对序号27的学生对应的位进行设置，表示他通过了测验
    quiz |= 1UL << 27;
    //equals to
    quiz = quiz | 1UL << 27;
    //若只有27号没有通过测验
    quiz = ~(quiz | 1UL << 27);
    //若在重新校对时发现27号没有通过测验
    quiz &= ~(quiz | 1UL << 27);

    //检查27号的status
    bool status = quiz & (1UL < 27);

    int* p;
    std::cout << sizeof * p << std::endl;


    return 0;
}